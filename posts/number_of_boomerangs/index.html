<!doctype html><html class="h-full w-full font-sans" lang=en-us><head>
<meta charset=utf-8>
<link rel="shortcut icon" href=http://example.org/favicon.ico type=image/x-icon>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>回旋镖的数量 - CengSin PERSONAL BLOG</title>
<meta property="og:title" content="回旋镖的数量">
<meta property="og:description" content="回旋镖的数量 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。 回旋镖 是由点 (i, j, k) 表示的元组 ， 其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 返回平面上所有回旋镖的数量。 示例 1： 输入：points = [[0,0],[1,0],[2,0]] 输出：2 解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 示例 2： 输入：points = [[1,1],[2,2],[3,3]] 输出：2 示例 3： 输入：points = [[1,1]] 输出：0 首先写一下自己的思路：本来我的思路是回旋镖中间的点到两边的点距离肯定是相同的。那么求回旋镖的数量就是 拿到一个符合中间点到两边点相同距离的元组的数量。到考虑元组的顺序这点我开始纠结了。这里记录一下。
元组的顺序肯定是不相同的，这里需要用到排列组合中的概念。
回想一下我的思路，一个点到其他两个点的距离相同。
Leetcode这里抽象成了到某个点距离相同的所有点的距离 m , 那么在m个点中拿出两个点与最外层点p组合成一个 回旋镖的元组即为排列，A(2, m) = m * (m - 1)
看代码：
func numberOfBoomerangs(points [][]int) (ans int) { for _, p := range points { cnt := make(map[int]int) for _, q := range points { dis := (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]) cnt[dis] ++ } for _, i := range cnt { ans += i * (i - 1) } } return ans } ">
<meta property="og:type" content="article">
<meta property="og:url" content="http://example.org/posts/number_of_boomerangs/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-13T11:15:13+08:00">
<meta property="article:modified_time" content="2021-09-13T11:15:13+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="回旋镖的数量">
<meta name=twitter:description content="回旋镖的数量 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。 回旋镖 是由点 (i, j, k) 表示的元组 ， 其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 返回平面上所有回旋镖的数量。 示例 1： 输入：points = [[0,0],[1,0],[2,0]] 输出：2 解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 示例 2： 输入：points = [[1,1],[2,2],[3,3]] 输出：2 示例 3： 输入：points = [[1,1]] 输出：0 首先写一下自己的思路：本来我的思路是回旋镖中间的点到两边的点距离肯定是相同的。那么求回旋镖的数量就是 拿到一个符合中间点到两边点相同距离的元组的数量。到考虑元组的顺序这点我开始纠结了。这里记录一下。
元组的顺序肯定是不相同的，这里需要用到排列组合中的概念。
回想一下我的思路，一个点到其他两个点的距离相同。
Leetcode这里抽象成了到某个点距离相同的所有点的距离 m , 那么在m个点中拿出两个点与最外层点p组合成一个 回旋镖的元组即为排列，A(2, m) = m * (m - 1)
看代码：
func numberOfBoomerangs(points [][]int) (ans int) { for _, p := range points { cnt := make(map[int]int) for _, q := range points { dis := (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]) cnt[dis] ++ } for _, i := range cnt { ans += i * (i - 1) } } return ans } ">
<link rel=stylesheet href="/css/styles.min.ad68f0a78b616fe22787e9ca587ae2ca7feee276768a8734e07b00f82d05b406717ad6f21da4b0d8b492f85c12b0ebba60220f8280067957da323c6a739a815f.css" integrity="sha512-rWjwp4thb+Inh+nKWHriyn/u4nZ2ioc04HsA+C0FtAZxetbyHaSw2LSS+FwSsOu6YCIPgoAGeVfaMjxqc5qBXw==">
<script>localStorage.theme==='dark'||!('theme'in localStorage)&&window.matchMedia('(prefers-color-scheme: dark)').matches?document.documentElement.classList.add('dark'):document.documentElement.classList.remove('dark')</script>
</head><body class="flex flex-col items-center w-full">
<main class="w-full sm:w-10/12 md:w-9/12 lg:w-7/12 xl:w-5/12 m-auto px-6"><header class="mt-9 mb-8">
<div class="flex justify-between items-center">
<div class="flex items-center">
<input id=navbar_btn class=hidden type=checkbox>
<label for=navbar_btn class="menu-btn mr-4 items-center flex xl:hidden">
<span class=navicon></span>
</label>
<a href=/ class="font-bold text-lg xl:text-2xl mr-auto">CengSin PERSONAL BLOG</a>
</div>
<div class="flex items-center">
<div class="cursor-pointer ml-2">
<svg id="dark_mode_btn" class="hidden" width="18" height="18" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M20 15.31 23.31 12 20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69zM12 18c-3.31.0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"/></svg></svg>
<svg id="light_mode_btn" class="hidden" width="18" height="18" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M0 0h24v24H0V0z" fill="none"/></g><g><g><g><path d="M14 2c1.82.0 3.53.5 5 1.35C16.01 5.08 14 8.3 14 12s2.01 6.92 5 8.65C17.53 21.5 15.82 22 14 22 8.48 22 4 17.52 4 12S8.48 2 14 2z"/></g></g></g></svg></svg>
</div>
</div>
</div>
<nav id=navbar class="mt-3 hidden xl:block"><ul class=flex></ul>
</nav>
<nav id=navbar_sm class="mt-2 hidden">
<ul>
</ul>
<hr class=my-4>
</nav>
</header>
<div id=content class=my-8>
<div class=my-7>
<article>
<h1 id=回旋镖的数量>回旋镖的数量</h1>
<pre tabindex=0><code>给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。
回旋镖 是由点 (i, j, k) 表示的元组 ，
其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。

返回平面上所有回旋镖的数量。

示例 1：

输入：points = [[0,0],[1,0],[2,0]]
输出：2
解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
示例 2：

输入：points = [[1,1],[2,2],[3,3]]
输出：2
示例 3：

输入：points = [[1,1]]
输出：0
</code></pre><p>首先写一下自己的思路：本来我的思路是回旋镖中间的点到两边的点距离肯定是相同的。那么求回旋镖的数量就是
拿到一个符合中间点到两边点相同距离的元组的数量。到考虑元组的顺序这点我开始纠结了。这里记录一下。</p>
<p><strong>元组的顺序肯定是不相同的，这里需要用到排列组合中的概念。</strong></p>
<p>回想一下我的思路，一个点到其他两个点的距离相同。</p>
<p>Leetcode这里抽象成了到某个点距离相同的所有点的距离 m , 那么在m个点中拿出两个点与最外层点p组合成一个
回旋镖的元组即为排列，A(2, m) = m * (m - 1)</p>
<p>看代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>numberOfBoomerangs</span>(<span style=color:#a6e22e>points</span> [][]<span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>ans</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>points</span> {
		<span style=color:#a6e22e>cnt</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>int</span>)
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>q</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>points</span> {
			<span style=color:#a6e22e>dis</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>p</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>q</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>*</span> (<span style=color:#a6e22e>p</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>q</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>+</span> (<span style=color:#a6e22e>p</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>q</span>[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>*</span> (<span style=color:#a6e22e>p</span>[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>q</span>[<span style=color:#ae81ff>1</span>])
			<span style=color:#a6e22e>cnt</span>[<span style=color:#a6e22e>dis</span>] <span style=color:#f92672>++</span>
		}

		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>cnt</span> {
			<span style=color:#a6e22e>ans</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span> (<span style=color:#a6e22e>i</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
		}
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ans</span>
}
</code></pre></div>
</article>
</div>
</div>
</main>
<script src=/js/header.0b11855b871cb4d10c6c07b6723b9209f5c2bc9100735ab6ff47c8f9b76bb3d6ae41b488083b5fb15697987334039eb651b25c83228c29ac48a2bc168db8a894.js integrity="sha512-CxGFW4cctNEMbAe2cjuSCfXCvJEAc1q2/0fI+bdrs9auQbSICDtfsVaXmHM0A562UbJcgyKMKaxIorwWjbiolA=="></script>
<script src=/js/zooming.10cfe42f65295a0596af3315b671956309ed1d20e299e476ca16f6f6b902421e29c6f81a8f9a7ce816f84bef0791dbad2e61e68ff8fe798bd9ce9e093756d084.js integrity="sha512-EM/kL2UpWgWWrzMVtnGVYwntHSDimeR2yhb29rkCQh4pxvgaj5p86Bb4S+8HkdutLmHmj/j+eYvZzp4JN1bQhA=="></script>
<script src=/js/code-copy-btn.78c2b9fa7e7343f48dedd4c678f6aa49b144aa7b7e28e43d5bf5d8604134f4b2353ca3be02e66b7ace7d6ddd780de243dd71f9073446df964728e38c386e484f.js integrity="sha512-eMK5+n5zQ/SN7dTGePaqSbFEqnt+KOQ9W/XYYEE09LI1PKO+AuZres59bd14DeJD3XH5BzRG35ZHKOOMOG5ITw=="></script>
</body>
</html>