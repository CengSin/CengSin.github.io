<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CengSin PERSONAL BLOG</title><link>http://example.org/</link><description>Recent content on CengSin PERSONAL BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 13 Sep 2021 11:15:13 +0800</lastBuildDate><atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml"/><item><title>回旋镖的数量</title><link>http://example.org/posts/number_of_boomerangs/</link><pubDate>Mon, 13 Sep 2021 11:15:13 +0800</pubDate><guid>http://example.org/posts/number_of_boomerangs/</guid><description>回旋镖的数量 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。 回旋镖 是由点 (i, j, k) 表示的元组 ， 其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 返回平面上所有回旋镖的数量。 示例 1： 输入：points = [[0,0],[1,0],[2,0]] 输出：2 解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 示例 2： 输入：points = [[1,1],[2,2],[3,3]] 输出：2 示例 3： 输入：points = [[1,1]] 输出：0 首先写一下自己的思路：本来我的思路是回旋镖中间的点到两边的点距离肯定是相同的。那么求回旋镖的数量就是 拿到一个符合中间点到两边点相同距离的元组的数量。到考虑元组的顺序这点我开始纠结了。这里记录一下。
元组的顺序肯定是不相同的，这里需要用到排列组合中的概念。
回想一下我的思路，一个点到其他两个点的距离相同。
Leetcode这里抽象成了到某个点距离相同的所有点的距离 m , 那么在m个点中拿出两个点与最外层点p组合成一个 回旋镖的元组即为排列，A(2, m) = m * (m - 1)
看代码：
func numberOfBoomerangs(points [][]int) (ans int) { for _, p := range points { cnt := make(map[int]int) for _, q := range points { dis := (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]) cnt[dis] ++ } for _, i := range cnt { ans += i * (i - 1) } } return ans }</description></item><item><title>不包含连续的1的整数</title><link>http://example.org/posts/non_negative_integers_without_consecutive_ones/</link><pubDate>Sun, 12 Sep 2021 15:39:42 +0800</pubDate><guid>http://example.org/posts/non_negative_integers_without_consecutive_ones/</guid><description>不包含连续的1的整数 给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。
示例 1:
输入: 5
输出: 5
解释: 下面是带有相应二进制表示的非负整数&amp;lt;= 5：
0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。
说明: 1 &amp;lt;= n &amp;lt;= 10^9
根据题目描述，我们可以拿到1～n每个数字的二进制，然后计算二进制不包含连续的1的整数的数量，返回即可。但是 题目中的n的取值范围为[1,10^9]，暴力肯定会超时。
我们要计算的是[0,n]范围内数字二进制不包含连续1的个数。
假设数字n的二进制位为：1001001，如何计算范围内数字二进制不包含连续1的个数？
首先我们假设数字开头为0，数字表示为0xxxxxx。0之后的二进制可以为1，可以为0。在这种情况下，我们唯一能够 确定的就是，开头的0那一位。xxxxxx中有多少个不包含连续1数字呢？我们先记下这个子问题。
其次我们假设数字开头为1，那么1之后的二进制位必须为0。重申一下，二进制中不包含连续1的数字。那么我们可以确定 开头的两位二进制10。那么数字可以表示为10xxxxx。xxxxx中有多少个不包含连续1的数字呢？
声明一个数组dp，下标i表示长度为i的二进制。dp[i]表示该二进制位不包含连续的1的数量。由于 数字的二进制的每一位不是0就是1，如果一个二进制的开头为0，那么它的的下一位就可以选择0，或者1。如果一个二 进制的开头为1，那么它的下一位只能是0，如果是1的话就不符合题目中要求的不包含连续的1。由此可以得出：
dp[i] = dp[i - 1] + dp[i - 2]
dp[i - 1] 表示 0开头的，长度为i-1的二进制中不包含连续1的数量 dp[i - 2] 表示 10开头的，长度为i-2的二进制中不包含连续1的数量</description></item><item><title>使用rand7实现rand10</title><link>http://example.org/posts/implement_rand10_use_rand7/</link><pubDate>Sun, 05 Sep 2021 14:50:20 +0800</pubDate><guid>http://example.org/posts/implement_rand10_use_rand7/</guid><description>使用rand7实现rand10 题目：
已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。 不要使用系统的 Math.random() 方法。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/implement-rand10-using-rand7 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 结论：
(RAND_X - 1) * Y + RAND_Y = RAND_X*Y RAND_X*Y % Y + 1 = RAND_Y 证明结论1：
使用rand2生成rand4
使用 rand2_Row + rand2_Col 生成的随机数为：
Col\Row 1 2 1 2 3 2 3 4 结果生成的范围为[2,4]
然后我们缩小结果的范围，用 rand2_Row - 1 替换 原来式子中的 rand2_Row，上面的式子就变成了：(rand2_Row - 1) + rand2_Col</description></item></channel></rss>