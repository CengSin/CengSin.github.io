---
title: "回旋镖的数量"
date: 2021-09-13T11:15:13+08:00
draft: false
---

# 回旋镖的数量

```
给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。
回旋镖 是由点 (i, j, k) 表示的元组 ，
其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。

返回平面上所有回旋镖的数量。

示例 1：

输入：points = [[0,0],[1,0],[2,0]]
输出：2
解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
示例 2：

输入：points = [[1,1],[2,2],[3,3]]
输出：2
示例 3：

输入：points = [[1,1]]
输出：0
```

首先写一下自己的思路：本来我的思路是回旋镖中间的点到两边的点距离肯定是相同的。那么求回旋镖的数量就是
拿到一个符合中间点到两边点相同距离的元组的数量。到考虑元组的顺序这点我开始纠结了。这里记录一下。

**元组的顺序肯定是不相同的，这里需要用到排列组合中的概念。**

回想一下我的思路，一个点到其他两个点的距离相同。

Leetcode这里抽象成了到某个点距离相同的所有点的距离 m , 那么在m个点中拿出两个点与最外层点p组合成一个
回旋镖的元组即为排列，A(2, m) = m * (m - 1)

看代码：

```go
func numberOfBoomerangs(points [][]int) (ans int) {
	for _, p := range points {
		cnt := make(map[int]int)
		for _, q := range points {
			dis := (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])
			cnt[dis] ++
		}

		for _, i := range cnt {
			ans += i * (i - 1)
		}
	}

	return ans
}
```
